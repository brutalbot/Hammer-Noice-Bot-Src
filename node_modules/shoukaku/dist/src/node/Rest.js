"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rest = void 0;
const undici_1 = require("undici");
/**
 * Wrapper around Lavalink REST API
 */
class Rest {
    /**
     * @param node An instance of Node
     * @param options.name Name of this node
     * @param options.url URL of Lavalink
     * @param options.auth Credentials to access Lavalnk
     * @param options.secure Weather to use secure protocols or not
     * @param options.group Group of this node
     */
    constructor(node, options) {
        this.node = node;
        this.url = `${options.secure ? 'https' : 'http'}://${options.url}`;
        this.auth = options.auth;
    }
    /**
     * Resolve a track
     * @param identifier Track ID
     * @returns A promise that resolves to a Lavalink response or void
     */
    async resolve(identifier) {
        const options = {
            endpoint: '/loadtracks',
            options: { params: { identifier } }
        };
        return await this.fetch(options);
    }
    /**
     * Decode a track
     * @param track Encoded track
     * @returns Promise that resolves to a track or void
     */
    async decode(track) {
        const options = {
            endpoint: '/decodetrack',
            options: { params: { track } }
        };
        return await this.fetch(options);
    }
    /**
     * Get routplanner status from Lavalink
     * @returns Promise that resolves to a routeplanner response or void
     * @internal
     */
    async getRoutePlannerStatus() {
        const options = {
            endpoint: '/routeplanner/status',
            options: {}
        };
        return await this.fetch(options);
    }
    /**
     * Release blacklisted IP address into pool of IPs
     * @param address IP address
     * @internal
     */
    async unmarkFailedAddress(address) {
        const options = {
            endpoint: '/routeplanner/free/address',
            options: {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: { address }
            }
        };
        return await this.fetch(options);
    }
    /**
     * Make a request to Lavalink
     * @param fetchOptions.endpoint Lavalink endpoint
     * @param fetchOptions.options Options passed to fetch
     * @internal
     */
    async fetch(fetchOptions) {
        const { endpoint, options } = fetchOptions;
        let headers = {
            'Authorization': this.auth,
            'User-Agent': this.node.manager.options.userAgent
        };
        if (options.headers)
            headers = { ...headers, ...options.headers };
        const url = new URL(`${this.url}${endpoint}`);
        if (options.params)
            url.search = new URLSearchParams(options.params).toString();
        const abortController = new AbortController();
        const timeout = setTimeout(() => abortController.abort(), this.node.manager.options.restTimeout || 15000);
        const request = await (0, undici_1.fetch)(url.toString(), {
            method: options.method?.toUpperCase() || 'GET',
            headers: { ...headers, ...options.headers },
            ...((['GET', 'HEAD'].includes(options.method?.toUpperCase() || 'GET')) && options.body ? { body: JSON.stringify(options.body ?? {}) } : {}),
            signal: abortController.signal
        });
        clearTimeout(timeout);
        if (request.status && (request.status >= 400))
            throw new Error(`Rest request failed with response code: ${request.status}`);
        if (!request.body)
            return null;
        const body = await request.json().catch(() => null);
        if (!body)
            return null;
        return body;
    }
}
exports.Rest = Rest;
//# sourceMappingURL=Rest.js.map